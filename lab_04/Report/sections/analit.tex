\documentclass[../main.tex]{subfiles}
\begin{document}
	
	В этом разделе описаны задачи, необходимые для достижения цели. Приведено математическое и детальное описание трех алгоритмов умножения матриц:
	
	\begin{enumerate}[1)]
		\item классический;
		\item винограда;
		\item винограда Модифицированный.
	\end{enumerate}
	
	\subsection{Постановка задачи}
	
	Цель: изучение способа распараллеливания алгоритма Винограда. 
	В данной работе рассматривается распараллеленная реализация стандартного алгоритма умножения матриц, алгоритма Винограда. \\
	
	Задачи:
	\begin{enumerate}[1)]
		\item рассмотреть задачу умножения матриц;
		\item произвести анализ сложности алгоритмов умножения матриц;
		\item запрограммировать алгоритмы и сделать их работу параллельной;
		\item сделать замеры времени для алгоритмов;
		\item результаты экспериментов сравнить с теоретическими оценками трудоёмкости;
		\item сделать выводы.
	\end{enumerate}

	\subsection{Классический подход}
	
	Предположим, что необходимо получить матрицу $C_{(a,c)} = A_{(a,b)} * B_{(b,c)}$. Для нахождения значений элементов матрицы $C_{(a,c)}$ используют следующие выражение\cite{makkonell}
	
	\begin{center}
		\begin{equation}
		\label{math:1}
		C_{i,j} = \sum_{K}(A_{i, k}B_{i,k})
		\end{equation}
	\end{center}
	
	Классический алгоритм напрямую реализует эту формулу
	
	\subsection{Алгоритм Винограда}
	
	Можно заметить, что элементы из суммы выражения \ref{math:1} можно переписать как:
	
	\begin{equation}
	A_{i, k-1}B_{k-1,j} + A_{i,k}B_{k,j} = (A_{i,k-1} + B_{k,j})(A_{i,k} + B_{k-1,j}) - A_{i,k-1}A_{i,k} - B_{k-1}B_{k,j}
	\end{equation}
	
	т. е. как сумму произведения сумм и двух произведений. Учитывая, что упомянутые два произведения можно рассчитать заранее для обработки двух элементов матрицы теперь нужно не сложение и два умножения, а умножение и два сложения, что проще с точки зрения вычислений. Таким образом, алгоритм Винограда состоит в следующем:
	
	\begin{enumerate}
		\item совершить расчет заранее двух произведений для каждого ряда и столбца матрицы-результата (одно произведение считается для ряда, другое для столбца). Для хранения результатов используется промежуточный буфер;
		
		\item по вышеприведённой формуле осуществить расчёт каждого элемента матрицы;
		
		\item в случае, если в произведении $A_{(a,b) X B_{b,c}}$ b – нечётное число, пройтись во второй раз по матрице, дополняя элементы $C_{i,j}$ недостающим элементом (который не был описан вышеописанной суммой). Можно заметить, что пункт 3 необходимо выполнять только в некоторых случаях, но если это происходит, то получается существенное увеличение времени работы алгоритма.
	\end{enumerate} 
	
	\subsection{Оптимизированный алгоритм Винограда}
	
	\begin{enumerate}
		\item Внутри тройного цикла накапливать результат в буфер, а вне цикла сбрасывать его в ячейку матрицы.
		\item Заменить MulH[i] = MulH[i] + … на MulH[i] += … (аналогично для MulV),
		где MulH и MulB – временные массивы для предварительного рассчета сумм произведений
	\end{enumerate}

	\subsection{Распараллеливание задачи на CPU}
		
		В рамках данной лабораторной работы производилось распараллеливание задачи по потокам. 
		В CPU для данной цели используются threads.
		
		Central Processing Unit (CPU) – это универсальный процессор, также именуемый процессором общего назначения. 
		Доступ к памяти с данными и инструкциями происходит преимущественно случайным образом.
		
		Архитектура x86 проектировалась специально таким образом, чтобы выполнять как можно больше инструкций параллельно. 
		Например для этого в ядрах процессора используется блок внеочередного выполнения команд.
		
		Но несмотря на это, CPU всё равно не в состоянии осуществить параллельное выполнение большого числа инструкций, так как расходы на распараллеливание инструкции внутри ядра увеличивают время работы программы. 
		Именно поэтому процессоры общего назначения имеют не очень большое количество исполнительных блоков.
	
	\subsection{Вывод}
	
	В данном разделе детально описаны 3 алгоритма умножения матриц: Классический, Винограда, модифицированная версия Винограда. Кратко описано про распараллеливание задач.
	
\end{document}