\documentclass[../main.tex]{subfiles}

\begin{document}
	
	В данном разделе описана цель и задачи необходимые для выполнения онной. Дано полное описание алгоритма Кнута - Моррса - Прата и Бойера - Мура и их математические описания.
	
\subsection{Цель и задачи}

	Целью данной работы является изучение способов поиска подстроки в строке с помощью алгоритмов Кнута-Мориса-Прата и Бойера-Мура. 
	Для достижения поставленной цели требуется решить следующие задачи:
	
	\begin{enumerate}
		\item изучить алгоритмы:
		\begin{enumerate}
			\item стандартный;
			\item Кнута-Мориса-Прата;
			\item Бойера-Мура;
		\end{enumerate}
		\item математически описать решение задачи поиска подстроки на основании выше указанных алгоритмов;
		\item реализовать выше указанные алгоритмы;
		\item сравнить;
		\item сделать выводы.
	\end{enumerate}
	
\subsection{Алгоритмы}

\subsubsection{Обзор алгоритма Кнута-Мориса-Прата}

	В задачах поиска информации одной из важнейших задач является поиск точно заданной подстроки в строке. 
	Примитивный алгоритм поиска подстроки в строке основан на переборе всех подстрок, длина которых равна длине шаблона поиска, и посимвольном сравнении таких подстрок с шаблоном поиска. \\
	
	Алгоритм Кнута-Морриса-Пратта является одним из первых алгоритмов с линейной оценкой в худшем случае. \\
	
	Обозначим через:
	
	\begin{equation}
		n = | heystack |, m = | needle |
	\end{equation}
	
	где |word|, обозначает длину слова word \\
	
	Префикс-функция строки $\pi$(S,i) – это длина наибольшего префикса строки S[1..i], который не совпадает с этой строкой и одновременно является ее суффиксом. 
	Проще говоря, это длина наиболее длинного начала строки, являющегося также и ее концом. 
	Для строки S удобно представлять префикс функцию в виде вектора длиной |S|-1. Можно рассматривать префикс-функцию длины |S|, положив $\pi$(S,1)=0. 
	Пример приведен на таблице \ref{tab:analit:1}
	
	\begin{table}
		\label{tab:analit:1}
		\caption{Пример префикс функции для строки abcdabca}
		\centering
		\begin{tabular}{|r|c|c|c|c|c|c|c|c|}
			\hline
			$S[i]$ &          a &          b &          c &          d &          a &          b &          c &          a \\
			\hline
			$\pi(S, i)$&          0 &          0 &          0 &          0 &          1 &          2 &          3 &          1 \\
			\hline
		\end{tabular}
	\end{table}
	
	\vspace{3mm}
	Наиболее полный алгоритм вычисления префикс-функции на псевдокоду показан в листинге \ref{Algorithm:1}
	
	\begin{algorithm}[H]
		\caption{Псевдокод функции поиска префикса}
		\label{Algorithm:1}
		\underline{алг} префикс\_функция (\underline{арг} строка S[1 ... i])
		\Begin{
			\emph{Преположим что $\pi(S, i) = k$}\;
			\eIf{$S[i + 1] = S[K + 1], \text{ то }$}{
				$\pi(S, i + 1) = k + 1$\;
			}
			{
				\eIf{$k = 0$}
				{$\pi(S, i + 1) = 0.$\;}
				{\text{ Положить} $k_i = \pi(S, k) \text{ и прейти к шагу 3}$\;}
			}
		}
	\end{algorithm}
	
	\vspace{3mm}
	Рассмотрим алгоритм Кнута-Морриса-Пратта. 
	Пусть S[0…m–1] – образец, T[0…n–1] – строка, в которой ведется поиск. 
	Рассмотрим сравнение строк на позиции i, то есть образец S[0…m–1] сопоставляется с частью строки T[i…i+m–1]. 
	Предположим, первое несовпадение произошло между символами S[j] и T[i+j], где i < j < m. Обозначим P = S[0…j–1] = T[i…i+j–1]. 
	При сдвиге можно ожидать, что префикс S сойдется с каким-либо суффиксом строки P. Поскольку длина наиболее длинного префикса, являющегося одновременно суффиксом, есть префикс-функция от строки S для индекса j, приходим к следующему алгоритму.
	
	\begin{enumerate}[1)]
		\item шаг 1: построить префикс-функцию образца S, обозначим ее F; \\
		\item шаг 2: положить k = 0, i = 0; \\
		\item шаг 3: cравнить символы S[k] и T[i].
		Если символы равны, увеличить k на 1.
		Если при этом k стало равно длине образца, то вхождение образца S в строку T найдено, индекс вхождения равен i – |S| + 1. 
		Алгоритм завершается. Пока k > 0, присвоим k = F[k–1] и переходим в начало шага 3; \\
		\item шаг 4: Пока i < |T|, увеличиваем i на 1 и переходим к шагу 3.
	\end{enumerate}


\subsection{Обзор алгоритма Бойера - Мура}

	Алгоритм сравнивает символы шаблона x справа налево, начиная с самого правого, один за другим с символами исходной строки y. 
	Если символы совпадают, производится сравнение предпоследнего символа шаблона и так до конца. 
	Если все символы шаблона совпали с наложенными символами строки, значит, подстрока найдена, и поиск окончен. 
	В случае несовпадения какого-либо символа (или полного совпадения всего шаблона) он использует две предварительно вычисляемых эвристических функции, чтобы сдвинуть позицию для начала сравнения вправо.
	
	Алфавит обозначим буквой $\sum$ Пусть |y|= n,|x|= m и |$\sum$|= $\sigma$. 
	Предположим, что в процессе сравнения возникает несовпадение между символом x[i]=a шаблона и символом y[i+j]=b исходного текста при проверке на позиции j. Тогда:
	
	\begin{equation}
		x[i + 1 ... m - 1] = y[i + j + 1 ... j +m - 1] = u
	\end{equation}
	
	и
	
	\begin{equation}
		x[i] \neq y[i + j]
	\end{equation}
	
	тогда m - i - 1 символом шаблона не совпало (оставшийся “хвост” подстроки). 
	В целом алгоритм можно описать с помощью трех ключевых положений.
	
\subsubsection{Сканирование слева направо, сравнение справа налево}

	Совмещается начало текста (строки) и шаблона, проверка начинается с последнего символа шаблона. 
	Если символы совпадают, производится сравнение предпоследнего символа шаблона и т. д. 
	Если все символы шаблона совпали с наложенными символами строки, значит, подстрока найдена, и выполняется поиск следующего вхождения подстроки. 
	Если же какой-то символ шаблона не совпадает с соответствующим символом строки, шаблон сдвигается на несколько символов вправо, и проверка снова начинается с последнего символа.

\subsubsection{Эвристика стоп-символа}

	Эвристика стоп-символа присутствует в большинстве описаний алгоритма Бойера — Мура, включая оригинальную статью Бойера и Мура, но не является необходимой для достижения оценки O(n+m) времени работы. Предположим, что мы производим поиск слова «колокол». Первая же буква не совпала — «к» (назовём эту букву стоп-символом). Тогда можно сдвинуть шаблон вправо до последней его буквы «к», что показано в таблице \ref{tab:analit:2}
	
	\begin{table}[H]
		\caption{Поиск слова колокол в строке к}
		\label{tab:analit:2}
		\begin{tabular}{|r|c|c|c|c|c|c|c|c|c|c|c|c|c|}
			\hline
			Строка &          * &          * &          * &          * &          * &          * &          к &          * &          * &          * &          * &          * &          * \\
			\hline
			Шаблон &          к &          о &          л &          о &          к &          о &          л &            &            &            &            &            &            \\
			\hline
			След. шаг &            &            &          к &          о &          л &          о &          к &          о &          л &            &            &            &            \\
			\hline
		\end{tabular}  
	\end{table}

	Если стоп-символ «к» оказался за другой буквой «к», эвристика стоп-символа не работает. 
	В таких ситуациях может быть полезна третья идея алгоритма Бойера — Мура — эвристика совпавшего суффикса.

\subsubsection{Эвристика совпавшего суффикса}
	
	Если при чтении шаблона справа налево совпал суффикс S, а символ b, стоящий перед S в шаблоне (т. е. шаблон имеет вид PbS), не совпал, то эвристика совпавшего суффикса сдвигает шаблон на наименьшее число позиций вправо так, чтобы строка S совпала с шаблоном, а символ, предшествующий в шаблоне данному совпадению S, отличался бы от b (если такой символ вообще есть). 
	Для данного шаблона s[0…m-1] считается целочисленный массив suffshift[0…m], в котором suffshift[i] равно минимальному числу j>0, такому, что s[i-j] $\neq$ s[i-1] и s[i-j+k]=s[i-1+k] для любого k>0, для которого выполняется 0 $\leq$ i-j+k < m и 0 $\leq$ i-1+k < m. \ref{tab:analit:3}
	
	\begin{table}[H]
		\caption{Поиск слова “скалкалка” в строке, рассмотрение суффикса “рка”}
		\label{tab:analit:3}
		\begin{tabular}{|r|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
			\hline
			Строка &          * &          * &          * &          * &          * &          * &          р &          к &          а &          * &          * &          * &          * &          * &            \\
			\hline
			Шаблон &          с &          к &          а &          л &          к &          а &          л &          к &          а &            &            &            &            &            &            \\
			\hline
			След. шаг &            &            &            &            &            &            &          с &          к &          а &          л &          к &          а &          л &          к &          а \\
			\hline
		\end{tabular}  
	\end{table}

	В данном случае совпал суффикс «ка», и шаблон сдвигается вправо до ближайшего «ка», перед которым нет буквы «л».
	
\subsection{Вывод}
	 
	 В данном разделе было приведено общее и алгоритмическое описание алгоритмов Кнута-Морриса-Пратта и Бойера-Мура, приведены примеры.
	
\end{document}