\documentclass[a4paper, 14pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{float}

\usepackage{listings}
\lstset{
	language=C++,
	numbers=left,
	frame=single,
	breaklines=true,
	breakatwhitespace=true,
	title=lstname,
	tabsize=4	
}

\usepackage{color}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage{url}
\usepackage{hyperref}

\usepackage{titlesec}
\titleformat*{\section}{\LARGE\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat*{\paragraph}{\large\bfseries}
\titleformat*{\subparagraph}{\large\bfseries}

\begin{document}
	\begin{titlepage}
		\begin{center}
			\begin{LARGE}
				Отчет по лабораторной работе №2\\
				по курсу "Анализ алгоритмов"\\
				по теме "Изучение алгоритмов умножения матриц "
			\end{LARGE}
			
			\begin{Large}
				\vspace{10cm}
				Студент: Барсуков Н.М. ИУ7-56\\
				Преподаватель: Волкова Л.Л.,
				Строганов Ю.В.
			\end{Large}
		\end{center}
	\end{titlepage}
	
	\tableofcontents
	
	\newpage
	\section*{Введение}
	
	Умножение матриц — это один из базовых алгоритмов, который широко применяется в различных численных методах, и в частности в алгоритмах машинного обучения. Многие реализации прямого и обратного распространения сигнала в сверточных слоях нейронной сети базируются на этой операции. Так порой до 90-95\% всего времени, затрачиваемого на машинное обучение, приходится именно на эту операцию. Так же это один из немногих алгоритмов, который позволяет эффективно задействовать все вычислительные ресурсы современных процессоров и графических ускорителей. Поэтому не удивительно, что многие алгоритмы стараются свести к матричному умножению — дополнительная расходы, связанные с подготовкой данных, как правило с лихвой окупаются общим ускорением алгоритмов

	\newpage
	\section{Аналитическая раздел}
	
	В этом разделе описаны задачи, необходимые для достижения цели. Приведено математическое и детальное описание трех алгоритмов умножения матриц:
	
	\begin{enumerate}
		\item Классический;
		\item Винограда;
		\item Винограда Модифицированный.
	\end{enumerate}
	
	\subsection{Постановка задачи}
	
	Цель: изучить алгоритмы умножения матриц \\
	
	Для достижения поставленной цели требуется решить следующие задачи: 
	
	\begin{enumerate}
		\item изучить
		\begin{enumerate}
			\item классический алгоритм умножения;
			\item алгоритм Винограда;
			\item модифицированный Винограда.
		\end{enumerate}
		\item реализовать указанные выше алгоритмы;
		\item разработать и реализовать оптимизированный алгоритм Винограда;
		\item выбрать модель оценки трудоемкости;
		\item сделать замеры алгоритмов;
		\item сравнить теоритические и эксперементальные оценки трудоемкости;
		\item сделать вывод.
	\end{enumerate}
	
	В данный момент существуют несколько алгоритмов перемножения матриц. Ниже в таблице 1 приведен их список с коэффициентом $\omega$, который показывает сложность алгоритмов $O(n^\omega)$
		
	В данном разделе будет приведено математическое описание алгоритмов перемножения матриц. Буду рассмотрены 3 подхода: классический, алгоритм Винограда и оптимизированный алгоритм Винограда.
	
	\subsection{Классический подход}
	
	Предположим, что необходимо получить матрицу $C_{(a,c)} = A_{(a,b)} * B_{(b,c)}$. Для нахождения значений элементов матрицы $C_{(a,c)}$ используют следующие выражение
	
	\begin{center}
		\begin{math}
		C_{i,j} = \sum_{K}(A_{i, k}B_{i,k})
		\end{math}
	\end{center}
		
	Классический алгоритм напрямую реализует эту формулу

	\subsection{Алгоритм Винограда}
	
	Можно заметить, что элементы из суммы выражения 1 можно переписать как:
	
	\begin{math}
		A_{i, k-1}B_{k-1,j} + A_{i,k}B_{k,j} = (A_{i,k-1} + B_{k,j})(A_{i,k} + B_{k-1,j}) - A_{i,k-1}A_{i,k} - B_{k-1}B_{k,j}
	\end{math}
	
	т. е. как сумму произведения сумм и двух произведений. Учитывая, что упомянутые два произведения можно рассчитать заранее для обработки двух элементов матрицы теперь нужно не сложение и два умножения, а умножение и два сложения, что проще с точки зрения вычислений. Таким образом, алгоритм Винограда состоит в следующем:
	
	\begin{enumerate}
		\item совершить расчет заранее двух произведений для каждого ряда и столбца матрицы-результата (одно произведение считается для ряда, другое для столбца). Для хранения результатов используется промежуточный буфер;
		
		\item по вышеприведённой формуле осуществить расчёт каждого элемента матрицы;
		
		\item в случае, если в произведении $A_{(a,b) X B_{b,c}}$ b – нечётное число, пройтись во второй раз по матрице, дополняя элементы $C_{i,j}$ недостающим элементом (который не был описан вышеописанной суммой). Можно заметить, что пункт 3 необходимо выполнять только в некоторых случаях, но если это происходит, то получается существенное увеличение времени работы алгоритма.
	\end{enumerate} 
	
	\subsection{Оптимизированный алгоритм Винограда}
	
	\begin{enumerate}
		\item Внутри тройного цикла накапливать результат в буфер, а вне цикла сбрасывать его в ячейку матрицы.
		\item Заменить MulH[i] = MulH[i] + … на MulH[i] += … (аналогично для MulV),
		где MulH и MulB – временные массивы для предварительного рассчета сумм произведений
		
	\end{enumerate}

	\subsection{Вывод}
	
	В данном разделе детально описаны 3 алгоритма умножения матриц: Классический, Винограда, модифицированная версия Винограда.
	
	\newpage
	\section{Конструкторский раздел}
	
	В данном разделе представлены блок схемы 2 алгоритмов умножения матриц: классический, Винограда, и схема вычисления rowFactor. Описана структура программы. Введена модель трудоемкости. Вычислены сложности алгоритмов.
	
	\subsection{Алгоритмы}
	
	В данном подразделе представлены схемы трех следующих алгоритмов умножения матриц: рисунок (\ref{fig:simple}) Классический, рисунок (\ref{fig:vinograd}) Винограда и схема вычисления rowFactor (\ref{fig:rowfactor})
	
	\vspace{1cm}
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.5]{Схемы/simple}
		\caption{Классический алгоритм}
		\label{fig:simple}
	\end{figure}
	
	\vspace{1cm}
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.5]{Схемы/vinograd}
		\caption{Алгоритм Винограда}
		\label{fig:vinograd}
	\end{figure}
	
	\vspace{1cm}
	\newpage
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.5]{Схемы/rowfactor}
		\caption{Rowfactor}
		\label{fig:rowfactor}
	\end{figure}


	\subsection{Модель трудоемкости}
	
	Основные правила оценки трудоемкости:
	\begin{enumerate}
		\item Операции единичной трудоемкости: +, -, *, /, %, <, <=, =>, >, ==, ! =, [], + =, − =, ∗ =, = =, ++, −−;
		\item C - подобная модель оценки трудоемкости циклов:
			\begin{enumerate}
				\item 
					\lstinline|for (int i = 0; i < N; i++){}| \\
					$ A = 2 + N * (2 + A()) $;
				\item
					\lstinline|for (int i = 0; i < N + 1; i++){}| \\
					$ A = 3 + N * (3 + A()) $.
				
			\end{enumerate}
	\end{enumerate}
	
	
	\subsection{Расчет сложности алгоритмов}
	
	\subsubsection{Классический алгоритм}	
	\begin{equation}
	\boxed{\begin{aligned}
		C[NxM] = A[QxN] * B[QxM] \\
		O(a, b, c) = 2 + 4N + 7NM + 12QMN \\ 
		\text{Цикл i = } 2 + 4N + 7NM + 12QMN \\
		\text{Цикл j = } 2 + 7M + 12QM \\ 
		\text{Цикл индекс = } 2 + 12Q \\ 
		\text{Тело индекс = } 10 \\	
		\end{aligned}}
	\end{equation}
	
	\subsubsection{Алгоритм Винограда}
	
	\begin{equation}
	\boxed{\begin{aligned}
		A = 
		\end{aligned}}
	\end{equation}	
	
	\subsubsection{Мод. Алгоритм Винограда}
	
	\begin{equation}
	\boxed{\begin{aligned}
		A = 
		\end{aligned}}
	\end{equation}
	
	
	
	\newpage
	\section{Технологический раздел}
	
	В данном разделе указаны минимальные системные требования. Описан используемый язык и среда разработки.
	Представлено описание интерфейса и его скриншоты. Приведен листинг 3 алгоритмов умножения матрицы.
	
	\subsection{Требования}
	
	Минимальные системные требования: PC с операционной системой Windows XP/Vista/7/8/10. Требуются устройства ввода: клавиатура, мышь. Устройство вывода: монитор (Без этого никуда)
	
	\subsection{Выбор языка и среды разработки}
	
	Для решения данной поставленной задачи, мной был выбран язык с++ стандарта \href{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf}{c11} по причине использования ООП. Так же использовалась среда \href{https://visualstudio.microsoft.com/ru/vs/}{Visual Studio 2019}
	
	\subsection{Интерфейс}
	
	Интерфейс представляет из себя простую консольную команду в которой пользователь видит временные результаты умножения матриц и результаты сравнения в процентном соотношении. Ниже придставлен скриншот выполнения (\ref{fig:interface}). Данный интерфейс выбран из за простоты и удобства.
	
	\begin{figure}
		\centering
		\includegraphics[width=0.7\linewidth]{screenshots/interface}
		\caption{Скриншот программы}
		\label{fig:interface}
	\end{figure}
	
	\subsection{Листинг}
	
	\subsubsection{Классический}
		
	\lstinputlisting[firstline=58, lastline=79] {../Matrix.cpp}
	
	\subsubsection{Винограда}
	
	\lstinputlisting[firstline=105, lastline=156]{../Matrix.cpp}
	
	\subsubsection{Виногорада улучшенный}
	
	\lstinputlisting[firstline=159, lastline=215]{../Matrix.cpp}
		
	\newpage
	\section{Исследовательский раздел}
	
	В данном разделе приведены характеристики машины на которых проводилось тестирование алгоритвом. Указаны замеры времени выполнения трех алгоритмов умножения матриц: Классического, Винограда и Винограда модифицированного.
	
	\begin{enumerate}
		\item Компьютер:
		\begin{enumerate}
			\item Тип компьютера   Компьютер с ACPI на базе x64;
			\item Операционная система   Microsoft Windows 10 Pro.
		\end{enumerate}
		\item Системная плата:
		\begin{enumerate}
			\item тип ЦП   DualCore Intel Core i5-6200U, 2700 MHz (27 x 100);
			\item системная плата   HP 8079;
			\item чипсет системной платы   Intel Sunrise Point-LP, Intel Skylake-U;
			\item системная память   8072 МБ (DDR4 SDRAM).
		\end{enumerate}
	\end{enumerate}
	
	\subsubsection{Debug}
	
	\begin{tabular}{|c|c|c|c|c|}
		\hline 
		Размерность\ Алгоритм & Классик & Классик ул. & Винограда & Винограда ул. \\ 
		\hline 
		100 & 140 & 78 & 78 & 62 \\ 
		\hline 
		200 & 982 & 422 & 452 & 312 \\ 
		\hline 
		300 & 3775 & 2949 & 3615 & 3026 \\ 
		\hline 
		400 & 6645 & 3145 & 3768 & 2839 \\ 
		\hline 
		500 & 21575 & 6240 & 7410 & 5648 \\ 
		\hline 
		600 & 26782 & 10811 & 12823 & 9865 \\ 
		\hline 
		700 & 35584 & 19036 & 21590 & 16645 \\ 
		\hline 
		800 & 53805 & 34741 & 39250 & 32885 \\ 
		\hline 
		900 & 94474 & 68406 & 82135 & 66846 \\ 
		\hline 
		100 & 141414 & 105394 & 111638 & 131493 \\ 
		\hline 
	\end{tabular} 

	\begin{tikzpicture}
		\begin{axis}[
			title = Сравнение, 
			xlabel=Размер матрицы,
			ylabel=Количество тиков]% coordinates
	
		\addplot[color=blue] coordinates { (100, 140)
									(200, 982)
									(300, 3775)
									(400, 6645)
									(500, 21575)
									(600, 26782)
									(700, 35584)
									(800, 53805)
									(900, 94474)
									(1000, 141414) };
		
		\addplot[color=black] coordinates{ (100, 78)
									(200, 422)
									(300, 2949)
									(400, 3145)
									(500, 6240)
									(600, 10811)
									(700, 19036)
									(800, 34741)
									(900, 68406)
									(1000, 105394) };
								
		\addplot[color=red] coordinates { (100, 78)
									(200, 452)
									(300, 3615)
									(400, 3768)
									(500, 7410)
									(600, 12823)
									(700, 21590)
									(800, 39250)
									(900, 82135)
									(1000, 105394) };
		
		\addplot[color=red] coordinates { (100, 62)
									(200, 312)
									(300, 3026)
									(400, 2839)
									(500, 5648)
									(600, 9865)
									(700, 16645)
									(800, 32885)
									(900, 66846)
									(1000, 131493) };
		
	\end{axis}
	\end{tikzpicture}
	
	\subsubsection{Release}
	
	\begin{tabular}{|c|c|c|c|c|}
		\hline 
		Размерность\ Алгоритм & Классик & Классик ул. & Винограда & Винограда ул. \\ 
		\hline 
		100 & 31 & 31 & 31 & 31 \\ 
		\hline 
		200 & 219 & 125 & 249 & 219 \\ 
		\hline 
		300 & 733 & 438 & 702 & 421 \\ 
		\hline 
		400 & 2544 & 1138 & 1373 & 845 \\ 
		\hline 
		500 & 3822 & 1826 & 2826 & 1966 \\ 
		\hline 
		600 & 9549 & 3562 & 5109 & 3764 \\ 
		\hline 
		700 & 25319 & 20239 & 25877 & 16430 \\ 
		\hline 
		800 & 33092 & 29881 & 31061 & 30251 \\ 
		\hline 
		900 & 132864 & 76041 & 56852 & 70562 \\ 
		\hline 
		1000 & 208147 & 235230 & 114093 & 128083 \\ 
		\hline 
	\end{tabular} 
	
	\begin{tikzpicture}
	\begin{axis}[
	title = Сравнение, 
	xlabel=Размер матрицы,
	ylabel=Количество тиков]% coordinates
	
	\addplot[color=blue] coordinates { (100, 31)
		(200, 219)
		(300, 733)
		(400, 2544)
		(500, 3822)
		(600, 9549)
		(700, 25319)
		(800, 33092)
		(900, 132864)
		(1000, 208147) };
	
	\addplot[color=black] coordinates{ (100, 31)
		(200, 125)
		(300, 438)
		(400, 1138)
		(500, 1826)
		(600, 3562)
		(700, 20239)
		(800, 29881)
		(900, 76041)
		(1000, 235230) };
	
	\addplot[color=red] coordinates { (100, 31)
		(200, 249)
		(300, 702)
		(400, 1373)
		(500, 2826)
		(600, 5109)
		(700, 25877)
		(800, 31061)
		(900, 56852)
		(1000, 114093) };
	
	\addplot[color=red] coordinates { (100, 31)
		(200, 219)
		(300, 421)
		(400, 845)
		(500, 1966)
		(600, 3764)
		(700, 16430)
		(800, 30251)
		(900, 70562)
		(1000, 128083) };
	
	\end{axis}
	\end{tikzpicture}
	
	
	\newpage
	\subsection{Вывод}
	
	Можно заметить значительно преимущество алгоритма Винограда над классическим алгоритмом, которое растет пропорционально размерности матриц. Улучшения для алгоритма Винограда дают чуть лучший результат, чем оригинальный алгоритм, но не всегда.
	Намного большую эффективность дает добавление флага оптимизации компилятора 03.
	
	
	\newpage
	\section*{Заключение}
	
	В ходе работы были исследованы два алгоритма умножения матриц: классический и Винограда. На квадратных матрицах размера от 100 до 1000, заполненных произвольными числами, было проведено сравнение скорости этих алгоритмов между собой, а также с их оптимизированными программными методами вариантами. Исследования проводились при компиляции с оптимизациями и без. Установлено, что алгоритм Винограда на достаточно больших размерах матриц (больше 800) дает значительный прирост в производительности. Программные оптимизации дают хороший результат при отключенных оптимизациях компилятора и незначительно лучший, а иногда и худший результат при включенных.
	
	\addcontentsline{toc}{section}{Список литературы}
	\begin{thebibliography}{4}
		\bibitem{makkonell}
		Дж. Макконнелл. Анализ алгоритмов. Активный обучающий подход.-
		М.:Техносфера, 2009.
		
		
		\bibitem{lev_pas}
		Методика идентификации пассажира по установленным данным В. М . Черненький , Ю. Е . Гапанюк [Электронный ресурс]. – Режим доступа: http://www.engjournal.ru/articles/89/89.pdf, свободный – (07.10.2019)
		
		\bibitem{dam_lev_habr}
		Библиография в LaTeX [Электронный ресурс]. – Режим доступа: https://habr.com/ru/post/114997/, свободный – (26.09.2019)
		https://habr.com/ru/post/114997/
		
		\bibitem{Latex_listings}
		The Listings Package [Электронный ресурс]. - Режим доступа: http://texdoc.net/texmf-dist/doc/latex/listings/listings.pdf, свободный - (11.12.2019)
		
	\end{thebibliography}
	
\end{document}

